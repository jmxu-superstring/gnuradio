2022年7月17日：
    我在我的github远程仓库中复刻了gnuradio的原始代码仓库，并将该复刻仓库克隆到了本地。
    接下来要做的，一是在本地阅读和试验源码并写下源码阅读笔记，二是将本地的工作同步到我的远程复刻仓库中去。


2022年7月20日：
    阅读完./VERSIONING，了解了gnuradio的版本命名规则。
    阅读了./README.md，了解了gnuradio的基本用途和基本安装方法。
    阅读了./DCO.txt，了解了软件开源的有关法律保护条款。
    阅读了./COPYING，了解了GPL3授权的有关条款。
    阅读了./CONTRIBUTING.md，了解了gnuradio的代码开发和提交规范等有关如何参与开发的信息。
    阅读了./CODE_OF_CONDUCT.md，了解了gnuradio社区的行为准则。
    阅读了./.readthedocs.yaml，了解了gnuradio项目文档的构建方法。

    阅读了./config.h.in，了解了gnuradio项目的一些全局宏定义，后续碰到这些宏可以定位到该文件原始出处。

    ./CHANGELOG.md文件的篇幅太长，且目前还未了解gnuradio的整体框架，不易最终该项目的改动历史，留到以后再研究。

    ./CMakeLists.txt文件的篇幅太长，且目前未掌握CMake的语法使用，留到以后再研究。
    ./CMakeLists.txt文件的解读
    （1）检查源码目录和编译二进制目录是否相同，若相同则给出警告提示；设置build选项为release。
    （2）工程设置：
        cmake的最低版本为3.8版；
        工程名：gnuradio
        语言：CXX C
        工程开启测试；
        设置build共享库；
    （3）......
        ...... 
        ......
    

    阅读了文件gnuradio-runtime/include/gnuradio/gr_complex.h
    该文件做了2件事：
        （1）类型定义了gr_complex为float精度的复数类型，
            类型定义了gr_complexd为double精度的复数类型。
        （2）提供了7个判断参数类型是否为复数的同名不同参内联函数is_complex，其中：
            认定gr_complex类型和gr_complexd类型的参数是复数，
            认定float、double、int、char、short类型的参数不是复数。
    
    阅读了文件gnuradio-runtime/include/gnuradio/attributes.h
    该文件做了4件事：
        （1）针对不同平台的不同编译器，定义了gunradio项目的跨平台编译属性宏定义，
            这里阅读源码使用的是GCC编译器
            #elif defined __GNUC__
            #define __GR_ATTR_ALIGNED(x) __attribute__((aligned(x)))
            #define __GR_ATTR_UNUSED __attribute__((unused))
            #define __GR_ATTR_INLINE __attribute__((always_inline))
            #define __GR_ATTR_DEPRECATED __attribute__((deprecated))
            #define __GR_ATTR_EXPORT __attribute__((visibility("default")))
            #define __GR_ATTR_IMPORT __attribute__((visibility("default")))
        （2）针对C语言编译定义了内联宏定义，
            这里阅读源码使用的是C++语言编译，内联是C++语言的关键字，是内置功能，所以不会被定义为宏。
        （3）针对微软MSC编译器的某些警告进行了屏蔽，
            这里阅读源码使用的是GCC编译器，不会做这些动作。
        （4）微软MSC编译器时，申请缓冲区空间的宏定义为
                #define __GR_VLA(TYPE, buf, size) TYPE* buf = (TYPE*)alloca(sizeof(TYPE) * (size))
            其他编译器时，申请缓冲区空间的宏定义为
                #define __GR_VLA(TYPE, buf, size) TYPE buf[size]
            通过搜索整个gnuradio工程发现，实际上用该宏定义申请缓冲区空间的例子只有一处，几乎不被使用，不必关注。
    
    阅读了文件gnuradio-runtime/include/gnuradio/api.h
    该文件做了2件事：
        （1）包含了文件gnuradio-runtime/include/gnuradio/attributes.h的属性宏定义。
        （2）条件定义宏GR_RUNTIME_API为上面文件的一个属性宏定义__GR_ATTR_EXPORT或__GR_ATTR_imPORT
    
    阅读了文件gnuradio-runtime/include/gnuradio/types.h
    该文件做了1件事：
        （1）类型定义了6种向量，其中包括：
            2种整形向量gr_vector_int、gr_vector_uint;
            2种浮点向量gr_vector_float、gr_vector_double;
            2种void指针向量gr_vector_void_star、gr_vector_const_void_star。
    
    阅读了gr-filter/include/gnuradio/filter/fir_filter.h
    该文件做了2件事：
        （1）在gr/filter/kernel的命名空间中，定义了fir_filter的类模板。
        （2）用6种不同的模板类型参数组合特例化了fir_filter类模板，如
            typedef fir_filter<float, float, float> fir_filter_fff;
            其他还包括：fir_filter_fff、fir_filter_ccf、fir_filter_fcc、fir_filter_ccc、fir_filter_scc、fir_filter_fsf，
            其中s指的是std::int16_t，即short的意思。






2022年7月20日：
    阅读了gr-analog/include/gnuradio/analog/sig_source_waveform.h
    该文件做了1件事：
        （1）定义了一个枚举类型gr_waveform_t，枚举了常数、正弦波、余弦波、方波、三角波、锯齿波共六种信号类型。
    
    阅读了gr-analog/include/gnuradio/analog/sig_source.h
    该文件做了3件事：
        （1）包含了sig_source_waveform.h文件，就可以使用六种信号类型的枚举值。
        （2）声明了信号源的类模板，信号源class是虚继承自同步型模块class。
            在信号源类中，类型定义了信号源类的共享指针sptr，sptr只用于信号源类的内部实现，外部代码无法直接使用sptr的类型定义，必须通过信号源类::sptr来使用（信号源类的子类信号源实现类中实现的信号源类make函数就是这么使用信号源类::sptr的）
            在信号源类中，声明了一个静态成员函数make，make函数根据采样率、波形类型、频率、幅度、偏置、初始相位这6个参数来生成一个信号源对象（多态的，实际上内部new了一个子类信号源实现类的对象），并返回该对象（子类对象和父类对象可以支持多态）的一个sptr共享指针，有了这个指针就可以引用到实际生成的信号源实现类对象。
            在信号源类中，还申明了6个纯虚函数（vitrual表示虚函数，=0表示类中不做具体的函数实现，const表示对类成员只能读取不能写入），分别返回信号源对象的6个参数。
            在信号源类中，还声明了6个纯虚函数，分别设置信号源对象的6个参数。
        （3）用int8_t、int16_t、int_32t、float、gr_complex共5种数值类型特例化了信号源类模板，以及类型定义别名。
    注意，信号源类中，并没有定义数据成员，而是定义了一系列的类接口（纯虚函数的作用），只有make函数被定义为静态成员函数，make函数在派生类中实现并巧妙地支持了多态。这样现make一个信号源对象并获取该对象指针，然后指针调用对象即可。估计该指针具有资源管理能力，不需要手工编码管理，因此也就看不到信号源对象的构造函数和析构函数来手工资源管理。

    阅读了gr-analog/lib/sig_source_impl.h
    该文件做了2件事：
        （1）包含了gnuradio/analog/sig_source.h，就可以继承信号源类。
            包含了gnuradio-runtime/include/gnuradio/fxpt_nco.h，就可以使用数控振荡器类。
        （2）声明了信号源实现的类模板，信号源实现class是继承自信号源class。
            在信号源实现类中，定义了6个数据成员，包括了信号源类中用到了6个参数中的5个（不含初始相位参数），还有一个数控振荡器的对象成员，该对象有初始相位的属性。
            申明了基于6个参数（和信号源类用到的6个参数相同）的信号源实现类构造函数。
            申明了析构函数（带有overide关键字，提醒父类即信号源类或者继续往上的祖先类的析构函数必须是vitrual函数，这样做的目的是为了保证多态下的对象正确析构，防止内存泄漏等问题）。
            在信号源实现类中，重载实现了信号源类中的12个纯虚函数。其中的6个获取信号源实现的成员参数的函数实现是在头文件里，只是简单地返回数据成员，初始相位是通过访问数控振荡器成员对象的初始相位来实现的。
            在信号源实现类中，另外6个重载的设置参数函数则是在信号源实现类的源文件中实现。
            另外，在信号源实现类中，还声明了两个其他函数，一个是work函数，另一个是set_cmd_msg函数。
            work函数实际上主要是调用了数控振荡器成员对象的方法来产生信号。
            set_cmd_msg函数则用于消息命令的处理。关键功能是work函数。
    
    阅读了gr-analog/lib/sig_source_impl.cc
    该文件是信号源实现类的源文件，做了12件事：
        （1）设置采样率方法，该方法除了设置采样率属性外，还根据当前的频率属性和采样率属性计算并设置了数控振荡器成员对象的数字角频率属性。
        （2）设置频率方法，该方法除了设置频率属性外，还根据当前的频率属性和采样率属性计算并设置了数控振荡器成员对象的数字角频率属性。
        （3）设置波形方法，该方法只是设置了波形属性，该属性属于枚举类型，有6种波形枚举值。
        （4）设置幅度方法，该方法只是设置了幅度属性。
        （5）设置偏置方法，该方法只是设置了偏置属性。
        （6）设置相位方法，该方法首先定义了一个互斥锁，但似乎没用，然后调用了数控振荡器对象的设置相位方法。
        （7）set_msg_handler方法。
        （8）利用6个信号源参数来构造对象的构造函数，该构造函数的构造过程：
                调用了祖父类sync_block的带参数构造函数；
                用参数对5个数据成员的列表初始化（初始化列表中不包括对数控振荡器成员对象的初始化）；
                在进入函数体之前，数控振荡器成员对象应该是得到了隐式的构造，调用了其默认的构造函数，查看源码发现，数控振荡器默认构造角频率为0和初始相位为0的对象；
                在构造函数的函数体中，调用设置频率和设置相位这2个方法，间接操作了对数控振荡器成员对象的数字角频率和初始相位的设置；
                在构造函数的函数体中，调用了祖先类basic_block的message_port_register_in方法；
                在构造函数的函数体中，调用了set_msg_handler方法。
        （9）析构函数，由于类成员里面只有5个基本数据类型成员和1个数控振荡器成员对象，且类方法里面没有申请什么需要释放的资源，所以析构函数的函数体中不需要实现什么资源释放操作；
        （10）work方法，有两个版本，一个是关于类型T的函数模板，另一个是专门将类型T特例化为gr_complex的函数。
            work方法的参数是通用的标准接口(int noutput_items, gr_vector_const_void_star& input_items, gr_vector_void_star& output_items)，
            该标准接口提供了一系列的输入和输出指针向量，每一个指针都指向输入输出的缓冲区，根据各种不同对象不同方法的需求提前专门分配好即可，将分配好的专门资源的指针提交通用接口即可，通用指针只是个资源指针收集器而已，而且是通用的viod型指针。
        （11）父类信号源的make函数是在其子类信号源实现中实现的，由于make函数是静态函数，在函数定义中要写明sig_source<T>::make，
            而在make函数体中，却用的是子类的类定义，而make函数返回类型却又是父类类型，这是种巧妙的多态机制，在函数体内部做专用具体实现，在函数体外部做通用接口封装，隔离了外部接口和内部实现。
        （12）用int8_t、int16_t、int_32t、float、gr_complex共5种数值类型特例化了信号源的模板类，在信号源实现类的源文件中特例化信号源类模板显得混乱。

    阅读了gr-analog/include/gnuradio/analog/noise_source.h
    该文件做了3件事：
        （1）包含了noise_type.h文件，就可以使用4种噪声类型的枚举值。
        （2）声明了噪声源的类模板，噪声源class是虚继承自同步型模块class。
            在噪声源类中，类型定义了噪声源类的共享指针sptr，用法如信号源类；
            在噪声源类中，声明了一个静态成员函数make，make函数根据噪声类型、幅度、种子这3个参数来生成一个噪声源对象并返回该对象的sptr共享指针。make函数的用法与信号源类的类似。
            在噪声源类中，还申明了2个纯虚函数（vitrual表示虚函数，=0表示类中不做具体的函数实现，const表示对类成员只能读取不能写入），分别返回噪声源对象的2个参数属性。
            在噪声源类中，还声明了2个纯虚函数，分别设置噪声源对象的2个参数属性。
        （3）用int16_t、int_32t、float、gr_complex共4种数值类型特例化了噪声源类模板，以及类型定义别名。
    注意，噪声源类中，并没有定义数据成员，而是定义了一系列的类接口（纯虚函数的作用），只有make函数被定义为静态成员函数，make函数在派生类中实现并巧妙地支持了多态。这样现make一个噪声源对象并获取该对象指针，然后指针调用对象即可。估计该指针具有资源管理能力，不需要手工编码管理，因此也就看不到信噪声对象的构造函数和析构函数来手工资源管理。

    阅读了gr-analog/lib/noise_source_impl.h
    该文件做了2件事：
        （1）包含了gnuradio/analog/noise_source.h，就可以继承噪声源类。
            包含了gnuradio-runtime/include/gnuradio/random.h，就可以使用伪随机数发生器类。
        （2）声明了噪声源实现的类模板，噪声源实现class是继承自噪声源class。
            在噪声源实现类中，定义了3个数据成员，包括了噪声源类中用到3个参数中的2个（不含种子参数），还有一个伪随机数发生器的对象成员，该对象有种子的属性。
            申明了基于3个参数（和噪声源类用到的3个参数相同）的噪声源实现类构造函数。
            没有专门的析构函数，编译器应该会自动生成默认的析沟函数。
            在噪声源实现类中，重载实现了噪声源类中的4个纯虚函数。其中的2个获取噪声源实现的属性参数的函数实现是在头文件里，只是简单地返回属性成员。
            在噪声源实现类中，另外2个重载的设置属性函数则是在噪声源实现类的源文件中实现。
            work函数实际上主要是调用了伪随机数发生器成员对象的方法来产生噪声。

    阅读了gr-analog/lib/noise_source_impl.cc
    该文件是噪声源实现类的源文件，做了8件事：
        （1）除了2个参数属性外，还有一个gr::random d_rng的成员对象，用来产生随机数。
        （2）设置噪声分布类型方法，该方法首先定义了一个互斥锁，然后设置了噪声分布类型属性，该属性属于枚举类型，有4种枚举值。
        （3）设置幅度方法，该方法首先定义了一个互斥锁，然后设置了幅度属性。另外有一个专门针对模板类型参数T为复数时的版本，区别就是将幅度参数除以根号2后再设置幅度属性。
        （4）没有重载父类的两个获取属性的纯虚函数。
        （5）利用3个噪声源参数来构造对象的构造函数，该构造函数的构造过程：
                调用了祖父类sync_block的带参数构造函数；
                用参数对3个数据成员的列表初始化；
                函数体为空。
            另外有一个专门针对模板类型参数T为复数时的构造函数，区别就是将幅度参数除以根号2后再设置幅度属性。
        （6）没有专门的析构函数，编译器应该会自动生成默认的析沟函数。
        （7）work方法，有两个版本，一个是关于类型T的函数模板，另一个是专门将类型T特例化为gr_complex的函数。
            work方法的参数是通用的标准接口(int noutput_items, gr_vector_const_void_star& input_items, gr_vector_void_star& output_items)，用法与其他模块类似。
            work方法中，调用了随机数成员对象d_rng的各种功能。
        （8）make函数的实现与信号源类的类似。
        （9）用int16_t、int_32t、float、gr_complex共4种数值类型特例化了噪声源的模板类，在噪声源实现类的源文件中特例化噪声源类模板显得混乱。
    
    阅读了gr-analog/include/gnuradio/analog/quadrature_demod_cf.h
    该文件是正交解调器类的头文件，做了1件事：
        （1）声明了正交解调器的类模板，正交解调器类是虚继承自同步型模块类。
            在该类中，类型定义了该类的共享指针sptr，用法和其他类一样；
            在该类中，声明了一个静态成员函数make，make函数根据该类构造参数来生成一个该类对象并返回其sptr共享指针。make函数的用法和其他类一样。
            在正交解调器类中，还申明了1个纯虚函数（vitrual表示虚函数，=0表示类中不做具体的函数实现，const表示对类成员只能读取不能写入），返回正交解调器对象的增益参数属性。
            在正交解调器类中，还声明了1个纯虚函数，设置正交解调器对象的增益参数属性。     
    注意，正交解调器类中，并没有定义数据成员，而是定义了一系列的类接口（纯虚函数的作用），只有make函数被定义为静态成员函数，make函数在派生类中实现并巧妙地支持了多态。这样现make一个正交解调器对象并获取该对象指针，然后指针调用对象即可。估计该指针具有资源管理能力，不需要手工编码管理，因此也就看不到信噪声对象的构造函数和析构函数来手工资源管理。

    阅读了gr-analog/lib/quadrature_demod_cf_impl.h
    该文件做了2件事：
        （1）包含了gr-analog/include/gnuradio/analog/quadrature_demod_cf.h，就可以继承正交解调器类。
        （2）声明了正交解调器实现的类模板，正交解调器实现类是继承正交解调器类。
            在正交解调器实现类中，定义了1个属性，即增益。
            申明了基于增益参数的正交解调器实现类构造函数。
            申明了标识有overide的析构函数。
            重载的2个方法，设置增益和获取增益，都在头文件中实现简单的赋值操作。
            work函数放到源文件中去实现。
    
    阅读了gr-analog/lib/quadrature_demod_cf_impl.cc
    该文件是正交解调器实现类的源文件，做了4件事：
        （1）利用1个增益参数来构造对象的构造函数，该构造函数的构造过程：
                调用了祖父类sync_block的带参数构造函数；
                用参数对增益属性的列表初始化；
                函数体做了一些对齐和其他操作。
        （2）析构函数，函数体为空。
        （3）work方法的参数是通用的标准接口(int noutput_items, gr_vector_const_void_star& input_items, gr_vector_void_star& output_items)，用法与其他模块类似。
            work方法中，调用了纯数学的计算，具体算法原理以后用到再研究。
        （4）make函数的实现与其他类的类似。
    
    阅读了frequency_modulator_fc的实现，实现的编码风格类似，关键是其work函数，work函数的具体功能不一定从源码中阅读，可以结合模块使用及其功能说明来理解。后续阅读源码的方法类似。

2022年10月27日：
    测试将本地的工作同步到我的远程复刻仓库中去。
    ￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥